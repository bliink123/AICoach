from flask import Flask, request, jsonify
from flask_cors import CORS
from datetime import date, timedelta, datetime
import json
# Assuming these helper functions are defined elsewhere, or in the same file
# from your_module import (
#     get_run_days_simple,
#     generate_workout_types_rule_based_phase_aware,
#     get_distance_factor,
#     generate_workout_details,
#     improve_run_schedule_rule_based,
#     get_default_weekly_mileage,
#     calculate_phase_multiplier,
#     determine_race_phase,
#     get_training_plan_length,
#     calculate_running_paces,
#     get_race_prediction, # Assuming you still need this
#     pace_str_to_minutes, # Assuming you still need this
#     generate_rest_day_details, # Assuming you still need this
#     calculate_intensity_score # Assuming you still need this
# )
# Assuming ScheduleCache and db are defined for caching (e.g., SQLAlchemy)
# from your_models import ScheduleCache, db

app = Flask(__name__)
CORS(app)

# --- Paste your helper functions here ---
def get_run_days_simple(week_days, run_days, long_run_day):
    """Simple method to get a set of run days, ensuring long_run_day is included."""
    selected_run_days = []
    if long_run_day not in week_days:
        raise ValueError("long_run_day must be in week_days")

    selected_run_days.append(long_run_day)  # Always include long run day

    # Select other run days (e.g., first few other days - adjust as needed)
    for day in week_days:
        if day != long_run_day and len(selected_run_days) < run_days:
            selected_run_days.append(day)

    return sorted(selected_run_days, key=lambda d: week_days.index(d)) # Keep sorted for consistency

def generate_workout_types_rule_based_phase_aware(race_phase, current_week, total_weeks, run_days, training_distance):
    """Generates workout types based on rules and race phase."""

    workout_rules_phase_aware = { #  <-- Define your 2D rules dictionary here (as shown previously)
        "base": {
            1: ["LongRun"],
            2: ["LongRun", "Easy"],
            3: ["LongRun", "Easy", "Easy"],
            4: ["LongRun", "Easy", "Easy", "Easy"],
            5: ["LongRun", "Easy", "Easy", "Easy", "Easy"],
            6: ["LongRun", "Easy", "Easy", "Easy", "Easy", "Easy"],
            7: ["LongRun", "Easy", "Easy", "Easy", "Easy", "Easy", "Easy"],
        },
        "build": {
            1: ["LongRun"],
            2: ["LongRun", "Easy"],
            3: ["LongRun", "Easy", "Threshold"],
            4: ["LongRun", "Easy", "Easy", "Threshold"],
            5: ["LongRun", "Easy", "Easy", "Threshold", "Easy"],
            6: ["LongRun", "Easy", "Easy", "Threshold", "Easy", "Easy"],
            7: ["LongRun", "Easy", "Easy", "Threshold", "Easy", "Easy", "Easy"],
        },
        "peak": {
            1: ["LongRun"],
            2: ["LongRun", "Easy"],
            3: ["LongRun", "Easy", "Intervals"],
            4: ["LongRun", "Easy", "Intervals", "Threshold"],
            5: ["LongRun", "Easy", "Intervals", "Threshold", "Easy"],
            6: ["LongRun", "Easy", "Intervals", "Threshold", "Easy", "Recovery"],
            7: ["LongRun", "Easy", "Intervals", "Threshold", "Easy", "Recovery", "Easy"],
        },
        "taper": {
            1: ["LongRun"],
            2: ["LongRun", "Easy"],
            3: ["LongRun", "Easy", "Easy"],
            4: ["LongRun", "Easy", "Easy", "Easy"],
            5: ["LongRun", "Easy", "Easy", "Easy", "Easy"],
            6: ["LongRun", "Easy", "Easy", "Easy", "Easy", "Easy"],
            7: ["LongRun", "Easy", "Easy", "Easy", "Easy", "Easy", "Easy"],
        },
    }

    if race_phase in workout_rules_phase_aware and run_days in workout_rules_phase_aware[race_phase]:
        workout_types = workout_rules_phase_aware[race_phase][run_days]
    else: # Handle cases where rules are not defined (optional - provide a default)
        workout_types = ["Easy"] * run_days # Default to easy runs if no specific rule

    return workout_types

def get_distance_factor(run_type, race_phase, current_week, total_weeks):
    base_factors = {"Recovery": 0.10, "Easy": 0.15, "Threshold": 0.12, "Intervals": 0.10, "LongRun": 0.25}
    factor = base_factors.get(run_type, 0.15)
    if run_type == "LongRun":
        if race_phase == "base":
            factor = 0.25 + (0.05 * current_week / (total_weeks * 0.3))
        elif race_phase == "build":
            factor = 0.30 - (0.02 * (current_week - (total_weeks * 0.3)) / (total_weeks * 0.5))
        elif race_phase == "peak":
            factor = 0.28
        elif race_phase == "taper":
            factor = 0.20 - (0.05 * (current_week - (total_weeks * 0.9)) / (total_weeks * 0.1))
    return factor

def generate_workout_details(run_type, race_phase, current_week, total_weeks, training_distance, distance):
    if run_type == "LongRun":
        if race_phase == "base":
            return f"Long run: {distance:.1f} km at an easy, conversational pace to build endurance."
        elif race_phase == "build":
            return f"Long run: {distance:.1f} km with the last 3-5 km at marathon pace."
        elif race_phase == "peak":
            if training_distance == "Marathon":
                return f"Long run: {distance:.1f} km with the middle {round(distance*0.5):.1f} km at race pace." # Corrected formatting here
            else:
                return f"Long run: {distance:.1f} km with a progressive effort, finishing strong."
        else:
            return f"Shorter long run: {distance:.1f} km at an easy pace."
    elif run_type == "Recovery":
        return f"Recovery run: {distance:.1f} km at a very relaxed pace."
    elif run_type == "Easy":
        return f"Easy run: {distance:.1f} km at a comfortable, steady pace."
    elif run_type == "Threshold":
        if race_phase == "base":
            return f"Threshold: {distance:.1f} km including 2-3 x 5 min at threshold pace."
        elif race_phase == "build":
            return f"Threshold: {distance:.1f} km with 20 minutes at threshold pace."
        elif race_phase == "peak":
            return f"Threshold: {distance:.1f} km with 2 x 15 min at threshold pace."
        else:
            return f"Threshold: {distance:.1f} km with 10 minutes at threshold pace."
    elif run_type == "Intervals":
        if training_distance in ["5K", "10K"]:
            if race_phase == "base":
                return f"Intervals: {distance:.1f} km with 6-8 x 400m at 5K effort."
            elif race_phase == "build":
                return f"Intervals: {distance:.1f} km with 5-6 x 800m at 5K effort."
            elif race_phase == "peak":
                return f"Intervals: {distance:.1f} km with 5 x 1000m at 5K effort."
            else:
                return f"Intervals: {distance:.1f} km with 3-4 x 400m at 5K effort."
        else:
            if race_phase == "build":
                return f"Intervals: {distance:.1f} km with 6-8 x 400m at 10K effort."
            elif race_phase == "peak":
                return f"Intervals: {distance:.1f} km with 3-4 x 1 mile at 10K effort."
            else:
                return f"Intervals: {distance:.1f} km with 4-5 x 400m at 10K effort."
    return f"{run_type} run: {distance:.1f} km."


def improve_run_schedule_rule_based(workout_types, long_run_day, week_days, run_days):
    """
    Improves run schedule by placing Long Run, Rest, and other workouts.
    Simplified for rule-based workout types.
    """
    final_schedule = {}
    final_schedule[long_run_day] = "LongRun" # Place Long Run First

    # Determine rest days (Simplified - example: 2 rest days, Monday and Friday if available, else distribute)
    rest_days_needed = 7 - run_days
    best_rest_days = [] # In a more complete version, you might still have some simplified rest day logic here if needed

    available_days_for_rest = [day for day in week_days if day != long_run_day]
    rest_days_to_assign = []

    if rest_days_needed >= 2:
        possible_rest_days = ["Monday", "Friday"] # Example preferred rest days
        for day in possible_rest_days:
            if day in available_days_for_rest and len(rest_days_to_assign) < rest_days_needed:
                rest_days_to_assign.append(day)
                available_days_for_rest.remove(day)

    # Fill remaining rest days if needed
    while len(rest_days_to_assign) < rest_days_needed and available_days_for_rest:
        rest_days_to_assign.append(available_days_for_rest.pop(0)) # Just take remaining available days

    best_rest_days = rest_days_to_assign


    # Assign rest days
    for day in best_rest_days:
        final_schedule[day] = "Rest"

    # Get remaining run days (excluding Long Run day and rest days)
    remaining_run_days = [day for day in week_days if day != long_run_day and day not in best_rest_days]

    # Assign remaining workouts in order to remaining run days
    workout_index = 0
    workout_types_for_schedule = [wt for wt in workout_types if wt != "LongRun"] # Exclude LongRun as it's already placed

    for day in remaining_run_days:
        if workout_index < len(workout_types_for_schedule):
            final_schedule[day] = workout_types_for_schedule[workout_index]
            workout_index += 1
        else: # Fill remaining days with Easy if workout_types are exhausted (shouldn't happen if rules are well-defined)
            final_schedule[day] = "Easy"

    return final_schedule

def get_default_weekly_mileage(training_distance, experience_level, training_goal):
    # Placeholder - replace with your actual logic
    if training_distance == "Marathon":
        return 50  # Example default for marathon
    elif training_distance == "Half Marathon":
        return 30 # Example for half marathon
    elif training_distance == "10K":
        return 20  # Example for 10k
    elif training_distance == "5K":
        return 15 # Example for 5k
    else:
        return 25 # Default

def calculate_phase_multiplier(race_phase, current_week, total_weeks):
    # Placeholder - replace with your actual logic to adjust mileage per phase
    if race_phase == "base":
        return 0.8 + (0.2 * current_week / total_weeks) # Gradually increase in base
    elif race_phase == "build":
        return 1.0 + (0.1 * current_week / total_weeks) # Further increase in build
    elif race_phase == "peak":
        return 1.1 # Peak mileage
    elif race_phase == "taper":
        return 0.7 - (0.6 * (current_week / total_weeks)) # Reduce significantly in taper
    return 1.0

def determine_race_phase(weeks_until_race, training_distance):
    # Placeholder - replace with your actual logic to determine race phase
    if weeks_until_race > 10:
        return "base"
    elif 6 <= weeks_until_race <= 10:
        return "build"
    elif 3 <= weeks_until_race < 6:
        return "peak"
    else:
        return "taper"

def calculate_running_paces(race_prediction, training_distance):
    # Placeholder - replace with actual pace calculation logic based on race_prediction
    paces = {
        "Easy": "5:30-6:30",
        "Recovery": "6:30-7:00",
        "Threshold": "4:30-4:45",
        "Intervals": "3:45-4:15",
        "LongRun": "5:45-6:45"
    }
    return paces

def get_race_prediction(garmin_client, today_str, training_distance):
    # Placeholder - replace with your actual logic to get race prediction (e.g., from Garmin API)
    return {"predicted_5k_pace": "25:00", "predicted_10k_pace": "52:00", "predicted_half_pace": "1:55:00", "predicted_marathon_pace": "4:10:00"}

def pace_str_to_minutes(pace_str):
    # Placeholder - replace with actual pace string to minutes conversion
    minutes, seconds = map(int, pace_str.split(':'))
    return minutes + seconds / 60.0

def generate_rest_day_details(rest_day_type):
    if rest_day_type == "Active Recovery":
        return "Light activity such as walking, stretching, or easy cycling for 20-30 minutes."
    elif rest_day_type == "Strength Training":
        return "Running-specific strength exercises for 30-45 minutes."
    else:
        return "Complete rest day to allow full recovery."

def calculate_intensity_score(run_type, distance, pace_minutes):
    if pace_minutes == "N/A" or pace_minutes is None:
        return 0
    intensity_factor = {"Recovery": 0.7, "Easy": 0.8, "Threshold": 1.0, "Intervals": 1.2, "LongRun": 0.85}.get(run_type, 0.8)
    return round(distance * intensity_factor * pace_minutes)


# --- API Endpoint ---
@app.route('/api/schedule', methods=['POST'])
def generate_schedule_endpoint():
    """
    Generates a personalized weekly running schedule based on user input using rule-based logic.
    """
    data = request.get_json()
    required_fields = ["runDays", "longRunDay", "trainingDistance", "raceDate", "racePhase"] # Keep required fields as before
    if not data or not all(field in data for field in required_fields):
        return jsonify({"error": "runDays, longRunDay, trainingDistance, raceDate, and racePhase are required"}), 400

    run_days = data.get("runDays")
    long_run_day = data.get("longRunDay").capitalize() # Keep capitalization
    training_distance = data.get("trainingDistance")
    race_date = data.get("raceDate")
    race_phase = data.get("racePhase").lower() # Keep lowercase conversion
    current_mileage = data.get("currentMileage") # Keep current_mileage
    experience_level = data.get("experienceLevel", "intermediate").lower() # Keep experience_level with default
    training_goal = data.get("trainingGoal", "pr").lower() # Keep training_goal with default

    week_days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
    if long_run_day not in week_days:
        return jsonify({"error": f"Invalid longRunDay. Must be one of: {', '.join(week_days)}"}), 400

    today = date.today()
    try:
        race_date_obj = date.fromisoformat(race_date)
    except Exception as e:
        return jsonify({"error": "Invalid raceDate format. Use YYYY-MM-DD."}), 400
    weeks_until_race = max(0, (race_date_obj - today).days // 7)

    if race_phase == "auto":
        race_phase = determine_race_phase(weeks_until_race, training_distance) # Keep race_phase determination

    total_weeks = get_training_plan_length(training_distance, experience_level) # Keep total_weeks calculation
    current_week = max(1, total_weeks - weeks_until_race) # Keep current_week calculation
    default_mileage = get_default_weekly_mileage(training_distance, experience_level, training_goal) # Keep default_mileage
    phase_multiplier = calculate_phase_multiplier(race_phase, current_week, total_weeks) # Keep phase_multiplier
    cycle_multiplier = 1.0 # Keep cycle_multiplier logic
    if current_week % 4 == 0:
        cycle_multiplier = 0.8
    elif current_week % 4 == 3:
        cycle_multiplier = 1.1
    weekly_mileage = current_mileage if current_mileage is not None else default_mileage * phase_multiplier * cycle_multiplier # Keep weekly_mileage

    # --- Caching Logic (Keep) ---
    cached_schedule = ScheduleCache.query.filter_by(
        race_date=race_date,
        training_distance=training_distance,
        race_phase=race_phase,
        run_days=run_days,
        long_run_day=long_run_day,
        current_mileage=weekly_mileage,
        experience_level=experience_level,
        training_goal=training_goal
    ).order_by(ScheduleCache.timestamp.desc()).first()
    if cached_schedule and (datetime.utcnow() - cached_schedule.timestamp) < timedelta(hours=24):
        return jsonify(json.loads(cached_schedule.schedule_json))
    # --- End Caching Logic ---

    running_days = get_run_days_simple(week_days, run_days, long_run_day) # Keep run_days function
    today_str = today.isoformat() # Keep today_str
    race_prediction = get_race_prediction(None, today_str, training_distance) # Keep race_prediction (assuming garmin_client is not needed now or is handled internally)
    if not race_prediction:
        return jsonify({"error": "Race prediction data not found"}), 404
    running_paces = calculate_running_paces(race_prediction, training_distance) # Keep pace calculation
    workout_types = generate_workout_types_rule_based_phase_aware(race_phase, current_week, total_weeks, run_days, training_distance) # USE NEW RULE-BASED FUNCTION

    final_schedule = improve_run_schedule_rule_based(workout_types, long_run_day, week_days, run_days) # USE NEW RULE-BASED FUNCTION

    schedule = [] # Keep schedule list for output
    for day in week_days:
        if day in final_schedule:
            run_type = final_schedule[day]
            if run_type in ["Recovery", "Easy", "Threshold", "Intervals", "LongRun", "Rest", "Active Recovery", "Strength Training"]: # Include Rest days as workout types
                target_pace = running_paces.get(run_type, "N/A")
                pace_minutes = pace_str_to_minutes(target_pace) if target_pace != "N/A" else None
                distance_factor = get_distance_factor(run_type, race_phase, current_week, total_weeks)
                run_distance = round(weekly_mileage * distance_factor, 1)
                run_duration = round(run_distance * pace_minutes) if pace_minutes else "N/A"

                if run_type in ["Rest", "Active Recovery", "Strength Training"]: # Handle rest day details
                    workout_details = generate_rest_day_details(run_type)
                else:
                    workout_details = generate_workout_details(run_type, race_phase, current_week, total_weeks, training_distance, run_distance)

                intensity_score = calculate_intensity_score(run_type, run_distance, pace_minutes)
                schedule.append({
                    "Day": day,
                    "WorkoutType": run_type,
                    "WorkoutDetails": workout_details,
                    "TargetPace": target_pace + " per km" if target_pace != "N/A" else target_pace,
                    "Duration": f"{run_duration} minutes" if run_duration != "N/A" else "N/A",
                    "Distance": f"{run_distance} km" if run_type not in ["Rest", "Active Recovery", "Strength Training"] else "N/A", # Distance for run workouts
                    "IntensityScore": intensity_score if run_type not in ["Rest", "Active Recovery", "Strength Training"] else 0 # Intensity for run workouts
                })
            else:
                schedule.append({ # Handle cases where workout_type is not recognized (shouldn't happen, but for safety)
                    "Day": day,
                    "WorkoutType": run_type,
                    "WorkoutDetails": "Workout details not available.",
                    "TargetPace": "N/A",
                    "Duration": "N/A",
                    "Distance": "N/A",
                    "IntensityScore": 0
                })
        else:
            schedule.append({ # Handle days with no scheduled workout (shouldn't happen anymore)
                "Day": day,
                "WorkoutType": "Rest",
                "WorkoutDetails": generate_rest_day_details("Rest"),
                "TargetPace": "N/A",
                "Duration": "N/A",
                "Distance": "N/A",
                "IntensityScore": 0
            })

    weekly_intensity = sum(item.get("IntensityScore", 0) for item in schedule if isinstance(item.get("IntensityScore"), (int, float))) # Keep intensity calculation
    schedule_summary = { # Keep schedule summary
        "weeklyMileage": round(weekly_mileage, 1),
        "weeklyIntensity": weekly_intensity,
        "currentWeek": current_week,
        "totalWeeks": total_weeks,
        "racePhase": race_phase,
        "weeksUntilRace": weeks_until_race
    }
    full_response = { # Keep full response structure
        "schedule": schedule,
        "summary": schedule_summary
    }

    schedule_json = json.dumps(full_response) # Keep JSON conversion and caching
    new_cache = ScheduleCache(
        race_date=race_date,
        training_distance=training_distance,
        race_phase=race_phase,
        run_days=run_days,
        long_run_day=long_run_day,
        current_mileage=weekly_mileage,
        experience_level=experience_level,
        training_goal=training_goal,
        schedule_json=schedule_json
    )
    db.session.add(new_cache)
    db.session.commit()

    return jsonify(full_response) # Return JSON response


if __name__ == '__main__':
    # Example of setting up database (if you are using SQLAlchemy and Flask-SQLAlchemy)
    # app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:' # Or your database URI
    # db.init_app(app)
    # with app.app_context():
    #     db.create_all()
    app.run(debug=True)